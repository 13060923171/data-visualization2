文档介绍

# 过程

首先就是读取数据，这个是第一步，因为数据量比较大，有30万行的数据，所以这里是采用jupyter来读取数据的，这样方面我们在后面分析的时候，直接调用，而不是反复读取，比较耗时

![image-20220325113036846](https://cdn.jsdelivr.net/gh/13060923171/images@main/img/image-20220325113036846.png)

然后根据里面的数据进行下一步分析，

纵观整个数据表格，其实能满足我们下一步分析就是产品描述这一行而已，可以从这一行来分析，判断商品是否存在价值

，像号码，时间，id，地区，这些其实并不重要

可以直接删除



然后我们从产品描述开始分析步骤，首先这个是英文

因此我们要先对其进行数据清洗的工作

![image-20220325113427129](https://cdn.jsdelivr.net/gh/13060923171/images@main/img/image-20220325113427129.png)

![image-20220325113436337](https://cdn.jsdelivr.net/gh/13060923171/images@main/img/image-20220325113436337.png)

![image-20220325113443363](https://cdn.jsdelivr.net/gh/13060923171/images@main/img/image-20220325113443363.png)

到这里为止都是数据清洗的工作，全部清洗完毕之后我们再来查看

![image-20220325113509014](https://cdn.jsdelivr.net/gh/13060923171/images@main/img/image-20220325113509014.png)

会发现，首先把数据格式化，全部小写，并且删除了一些无意义的词，并且对这些词进行分词

接着我们再把这些分好的词用记事本保存下来，方便我们后面分析的工作，可以直接读取这个记事本，而不是重复读取上面的步骤

![image-20220325113637359](https://cdn.jsdelivr.net/gh/13060923171/images@main/img/image-20220325113637359.png)

然后我们再用tf-idf进行计算每一行的值

![image-20220325113806758](https://cdn.jsdelivr.net/gh/13060923171/images@main/img/image-20220325113806758.png)

计算它们的权重

接着我们再用聚类的方法进行分类

![image-20220325113842574](https://cdn.jsdelivr.net/gh/13060923171/images@main/img/image-20220325113842574.png)

这里有一点要注意的，我之所以用 MiniBatch Kmeans而不是用Kmeans是因为样本量较大

### 聚类算法选择

面对上面的对比结果，并不是某几个算法不好，而是每一种方法适用的情况都各不相同。下面，我们就简单地说明一下，聚类算法的选择步骤：

**1.** 如果已知 K 值，即聚类的数量：

- 样本数量 < 1 万，首选 Kmeans，效果不好再选择 SpectralClustering。
- 样本数量 > 1 万，首选 MiniBatch Kmeans。

根据经验来说都是这样去选择的，而且用Kmeans也会因为样本量较大，导致一直报错无法运行，所以只能用MiniBatch Kmeans





![image-20220325114055851](https://cdn.jsdelivr.net/gh/13060923171/images@main/img/image-20220325114055851.png)

最后的分析结果如图所示

因为这里采用的是无监督的机器学习，所以并不能指定这个具体的数到底代表的是什么，因为每次运算，结果都会发生改变，其数字背后代码的含义也会随之改变

![image-20220325114316541](https://cdn.jsdelivr.net/gh/13060923171/images@main/img/image-20220325114316541.png)

这是它的结果分类



在这里0 可以代表是否畅销，1可以代表具备高盈利能力，2代表退货率较高，

但是在下次运行的时候，这个也会随之发生改变

其代表的含义可以反着来，所以不能写死它对应的定义

